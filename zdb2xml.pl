#!/usr/bin/perl
#
# Usage: ./zdb2xml.pl <ZDB-FILE [>XML-FILE]
#
# This is a script to convert a .zdb file (generated by `xml2zdb.pl`) back into
# XML. This recreates the original XML (as far as possible, some things, such
# as uneven indentation in the original XML cannot be fully preserved).
#
# If standard output is on a terminal (i.e. no `>XML-FILE` is specified, and
# output isn't piped to `less` or similar), then the existing `mem-*.xml` files
# will be overwritten. (A backup of the original files will be kept, given a
# '.TIMESTAMP.bak' suffix.)
#
# If you do redirect the output, then only a single XML file will be output,
# with XML comments indicating where the data would be cut into different files
# (the comments look like this: `<!--* FILE: mem-00-header.xml *-->`).
#
# WORKFLOW
# ========
# The `xml2zdb.pl` and `zdb2xml.pl` are convenience scripts to simplify the
# database editing (for me, zrajm). Emacs (the editor I use) chokes on large
# XML files (which are not exactly human-friendly anyway) so in order to work
# around this, I do my editing in a plain text 'database' format of my own
# devising (this format is also used for the Klingonska Akademien Klingon
# dictionary, http://klingonska.org/dict/dict.zdb).
#
# Thus I first convert the {boQwI'} XML to ZDB format, using:
#
#     ./xml2zdb >mem.zdb
#
# After having done the any editing I desire, I convert the ZDB back to XML
# with the command:
#
#     ./zdb2xml <mem.zdb
#
# (This will overwrite the original {boQwI'} files, but keep backups of the
# previously existing files.)
#
# /zrajm [2022-08-05]

use warnings;
use strict;
use utf8;
binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';

my @field_name = (
    ['_id', '_id'],
    ['tlh', 'entry_name'],
    ['pos', 'part_of_speech'],
    ['en', 'definition'],
    ['de', 'definition_de'],
    ['fa', 'definition_fa'],
    ['sv', 'definition_sv'],
    ['ru', 'definition_ru'],
    ['hk', 'definition_zh_HK'],
    ['pt', 'definition_pt'],
    ['fi', 'definition_fi'],
    ['syn', 'synonyms'],
    ['ant', 'antonyms'],
    ['see', 'see_also'],
    ['com-en', 'notes'],
    ['com-de', 'notes_de'],
    ['com-fa', 'notes_fa'],
    ['com-sv', 'notes_sv'],
    ['com-ru', 'notes_ru'],
    ['com-hk', 'notes_zh_HK'],
    ['com-pt', 'notes_pt'],
    ['com-fi', 'notes_fi'],
    ['hid', 'hidden_notes'],
    ['part', 'components'],
    ['cf-en', 'examples'],
    ['cf-de', 'examples_de'],
    ['cf-fa', 'examples_fa'],
    ['cf-sv', 'examples_sv'],
    ['cf-ru', 'examples_ru'],
    ['cf-hk', 'examples_zh_HK'],
    ['cf-pt', 'examples_pt'],
    ['cf-fi', 'examples_fi'],
    ['tag-en', 'search_tags'],
    ['tag-de', 'search_tags_de'],
    ['tag-fa', 'search_tags_fa'],
    ['tag-sv', 'search_tags_sv'],
    ['tag-ru', 'search_tags_ru'],
    ['tag-hk', 'search_tags_zh_HK'],
    ['tag-pt', 'search_tags_pt'],
    ['tag-fi', 'search_tags_fi'],
    ['ref', 'source'],
);

# Unescape XML entities (convert plain char '&' into XML entity '&amp;' etc).
{
    my %chr = ('<' => 'lt', '>' => 'gt', '&' => 'amp');
    my $chr = qr/[@{[ join '', keys %chr ]}]/;
    sub escape_xml {
        local ($_) = @_;
        s/$chr/&$chr{$&};/g;
        return $_;
    }
}

{
    my $doctype = '';
    my $header = '';
    my $indent = '';
    sub output_doctype {
        print "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
        $doctype = 1;
    }
    sub output_header {
        if (not $header) {
            print "<sm_xml_export version=\"2.0\">\n";
            print "  <database name=\"qawHaq.sqlite\">\n";
            $header = 1;
            $indent = '    ';
        }
    }
    sub output_record {
        my @rec = @_;
        my $has_field = '';
        my $i = 0;
        for my $x (@rec) {
            if ($x->[0] ne '/*') {
                $has_field = 1;
                last;
            }
        }
        output_doctype() if not $doctype;
        output_header()  if $has_field and not $header;
        if ($has_field) {
            print "    <table name=\"mem\">\n";
            $indent = '      ';
        }
        for my $x (@rec) {
            my ($key, $value) = @$x;
            chomp($value);
            $value = escape_xml($value);
            if ($key eq '/*') {                     # comment
                # If comment starts with '<!-- ...' its wordwrapped (and needs
                # to be unwrapped), but if it starts with '<!--\n' (the '<!--'
                # part on a separate line) we only re-indent it.
                if (substr($value, 0, 1) ne "\n") { #   word wrapped (so unwrap)
                    $value =~ s/(.)\n/$1 eq '¶' ? "\n" : "$1 "/ge;
                } else {
                    $value =~ s/^(?!$)/$indent    /mg;
                    $value =~ s/\n$/\n$indent/;
                }
                printf "$indent<!--%s-->\n", $value;
            } else {                           # field
                if ($key eq 'tlh') {
                    $value =~ s/^\{(.*)\}$/$1/s;
                }
                while ($i < @field_name and $field_name[$i][0] ne $key) {
                    printf "$indent<column name=\"%s\"></column>\n", $field_name[$i][1];
                    $i ++;
                }
                if ($i < @field_name) {
                    $value =~ s/(.)\n/$1 eq '¶' ? "\n" : "$1 "/ge;
                    die "$i $#field_name $.\n" if not defined $field_name[$i][1];
                    if ($value eq '') {
                        printf "$indent<column name=\"%s\"></column>\n",
                            $field_name[$i][1];
                    } else {
                        printf "$indent<column name=\"%s\">%s</column>\n",
                            $field_name[$i][1], $value;
                    }
                    $i ++;
                }
            }
        }
        if ($i) {
            while ($i < @field_name) {
                die "$i $#field_name $.\n" if not defined $field_name[$i][1];
                printf "$indent<column name=\"%s\"></column>\n", $field_name[$i][1];
                $i ++;
            }
        }
        if ($has_field) {
            $indent = '    ';
            print "$indent</table>\n";
        }
    }
    sub output_footer {
        if ($header) {
            print "  </database>\n";
            print "</sm_xml_export>\n";
        }
    }
}

{
    my $fh;
    my $file;
    use POSIX;
    sub redirect_to_file {
        ($file) = @_;
        output_header() if $fh;
        close_file();
        print STDERR "Writing file '$file'...\n";
        if (-e $file) {
            my $bakfile = "$file.@{[strftime('%FT%T', localtime $^T)]}.bak";
            -e $bakfile and die "Backup file '$file' already exists\n";
            rename $file, $bakfile or die "Failed to rename file '$file' -> '$bakfile'\n";
        }
        open($fh, ">:utf8", $file) or die "Failed to open file '$file' for writing\n";
        select $fh;
    }
    sub close_file {
        close($fh) or die "Failed to close file '$file' after writing\n" if $fh;
    }
}

my (@rec, $fname);
my $split_into_files = -t STDOUT;
die "$0: No input provided on standard input\n" if -t STDIN;
LINE: foreach (<STDIN>) {
    if (@rec and $rec[-1][0] eq '/*' and $rec[-1][2] eq '') {  # comment continuation
        if (s#[*]/$##) { $rec[-1][2]  = '*/' }                 #   end of comment
        $rec[-1][1] .= $_;
    } elsif ($_ eq "\n") {                                     # blank line
        output_record(@rec) if @rec;
        @rec = ();
    } elsif (substr($_, 0, 2) eq '/*') {                       # comment start
        $_ = substr($_, 2);
        if (s#[*]/$##) {                                       #   one-line comment
            if (/[*] FILE: (.*?) [*]/ and $split_into_files) { #   new output file
                output_record(@rec) if @rec;
                @rec = ();
                redirect_to_file($1);
                next LINE;
            }
            push(@rec, ['/*', $_, '*/']);
        } else {                                               #   multi-line comment
            push(@rec, ['/*', $_, '']);
        }
    } else {                                                   # record data
        my ($name, $value) = split('\t', $_, 2);
        if ($name =~ /^([a-zA-Z0-9_-]+):$/) {                  #   field
            $fname = $1;
            push(@rec, [$fname, $value]);
        } elsif ($name eq '') {                                #   field continuation
            $rec[-1][-1] .= $value;
        } else {                                               #   syntax error
            die "Malformed ZDB in line $., '$_'\n";
        }
    }
}
output_record(@rec) if @rec;
output_footer();
close_file();

#[eof]
